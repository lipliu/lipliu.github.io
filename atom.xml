<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>lipliu.blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-07-31T11:54:50.013Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>lipliu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何定位web前后端bug</title>
    <link href="http://yoursite.com/2020/07/31/%E5%A6%82%E4%BD%95%E5%AE%9A%E4%BD%8Dweb%E5%89%8D%E5%90%8E%E7%AB%AFbug/"/>
    <id>http://yoursite.com/2020/07/31/%E5%A6%82%E4%BD%95%E5%AE%9A%E4%BD%8Dweb%E5%89%8D%E5%90%8E%E7%AB%AFbug/</id>
    <published>2020-07-31T11:52:32.000Z</published>
    <updated>2020-07-31T11:54:50.013Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Jul 31 2020 20:37:09 GMT+0800 (GMT+08:00) --><p><strong>一、对系统整体的了解</strong></p><p><strong><a href="http://www.51testing.com/html/69/javascript:;" target="_blank" rel="noopener">Server</a>端：</strong>jsp+Servlet+json</p><p><strong><a href="http://www.51testing.com/html/69/javascript:;" target="_blank" rel="noopener">数据库</a>：</strong>sql、MySQL、oracle等</p><p><strong>前台：</strong> 涉及到 jstl，jsp，js，css，htm等方面</p><p><strong>后台：</strong>servlet，jms，ejb， 还有很多框架，struts，hibernate，spring，ibatis</p><p><strong>Jsp：</strong>分不清前后台的，因为这里涉及到一个运行时刻的问题，它们的运行时刻是不同。</p><p>用户发出请求后，服务器解析用户请求，转至对应的jsp，这个时候可以说是整个jsp都是后台程序。</p><p>而Jsp做出响应后，把响应的内容返回给<a href="http://www.51testing.com/html/69/javascript:;" target="_blank" rel="noopener">浏览器</a>，这个时候浏览器就只看见html,css,javascript，这个时候所有的程序又都是前台程序。</p><p><strong>二、前后台bug定位</strong></p><p><strong>1. 前台的bug通常是功能、界面和兼容性等有关；后台的bug与性能和安全性有关。</strong></p><p>前台bug定位：按F12在控制台中查看报错信息，对于出错的js可以在Sources下查看对应报错的资源文件，写入缺陷管理工具提交给开发即可（或者使用一些抓包工具，</p><p>抓取请求相应过程中的资源文件）</p><p>前台bug注意以下三个方面：</p><p><strong>1）</strong>网站前台权限控制：没有权限的用户不能直接输入url的方式来进行访问，必须进行登录。以后涉及到权限的<a href="http://www.51testing.com/html/69/javascript:;" target="_blank" rel="noopener">测试</a>，一定不能漏掉url的方式也需要验证一下。</p><p>而在单个页面进行W3C测试时则需要去掉该权限控制。</p><p><strong>2）</strong>网站前台的title，对于这个也很容易忽视。进入到不同的功能页面，title显示应该是有，并且要和你进入的页面一致。title就是在浏览器最左上角看到的那些文字</p><p><strong>3）</strong>http和https的注意点：</p><p>https是一种安全链接，需要证书，所以在系统中客户会要求某些关键的地方希望加上这种安全连接，那么此时你需要注意的是：对于不需要的安全链接的地方千万也要去</p><p>重点测试，有些开发会很容易忽略这一点。</p><p>要打开HTTPS开头的网站，前提是该网站安装了SSL证书，只有安装了SSL证书的网站，并且开启了443端口，你才可以通过HTTPS加密协议无访问；如果没有则不能访问。</p><p>比如在某个网站http协议后面加个s去访问，看能否访问成功，能成功，会显示绿色安全小锁，否则就不能访问。</p><p><strong>2.**</strong>后台bug定位：根据后台日志文件**</p><p>系统使用secureCRT进行日志获取，或者服务器控制方面的操作（关闭和重启）</p><p>重启的一般情况：</p><p>​ <strong>1）</strong>热部署 （新增部分功能，或者修改部分bug)</p><p>​ <strong>2）</strong>发布新版本 （整个系统）</p><p>​ <strong>3）</strong>内存溢出，此时重启服务器即可</p><p>由于项目中有线程程序，./shutdown脚本关闭tomcat程序，不能把启动的线程全部关闭，造成服务器启动线程未关闭的错误。</p><p><a href="http://www.51testing.com/html/69/javascript:;" target="_blank" rel="noopener">Linux</a>系统中重启Tomcat的一般步骤：（一般是先关闭进程，然后进行重启 ，如果/要删除某个文件：rm 文件名，或者不为空的文件夹：rm -rf 文件夹名）</p><p>cd usr/local/ //测试服务器名称/bin</p><p>ps -exf //看测试服务器下运行的项目的主进程（最前面的数字为PID进程号）</p><p>kill -9 PID //强制关闭某一项目的主进程</p><p>./startup.sh // ./**.sh 即执行重启<a href="http://www.51testing.com/html/69/javascript:;" target="_blank" rel="noopener">shell</a>脚本文件 ，此时在测试服务器的bin下面，直接执行即可，其余的加上 chmod a+x shell脚本文件，也可用./执行</p><p><strong>小知识</strong>：</p><p>ps aux和ps -ef命令区别</p><p>ps aux 是用BSD的格式来显示<a href="http://www.51testing.com/html/69/javascript:;" target="_blank" rel="noopener">java</a>这个进程</p><p>显示的项目有：USER,PID,%CPU,%MEM,VSZ,RSS,TTY,STAT,START,TIME,COMMAND</p><p>ps -ef 是用标准的格式显示java这个进程</p><p>显示的项目有：UID,PID,PPID,C,STIME,TTY,TIME,CMD）</p><p><strong>3.如何查看日志？</strong></p><p>一台服务器可以部署多个应用：</p><p>cd usr/local/测试服务器名称/logs //查看先进入到服务器的logs目录下</p><p>tail -f catalina.out //监视catalina.out 文件的尾部内容（默认10行）</p><p><strong>4.**</strong>日志中常见的问题**</p><p>获取日志文件中常遇到的问题：</p><p><strong>1)</strong>编码问题：tomcat是新的，需要改编码 修改tomcat的server.xml文件<connector port="8080" uriencoding="UTF-8"></connector></p><p>特别是windows下的项目重新部署到linux系统下，</p><p><strong>2)</strong>空指针：程序问题，一般没有考虑到为空情况，或者主外键约束的数据为空，或者删除关联数据，导致为空</p><p><strong>3)</strong>长度过长，超过最大长度，测试环境修改数据库字段长度后生产环境未修改，导致报错！！</p><p><strong>4)</strong>非法数据：</p><p><strong>5)</strong>内存溢出：重启</p><p><strong>5.**</strong>一般的问题原因总结：**</p><p>程序：为空判断，增删改查,不同公众号调用的接口也不一样</p><p>数据初始化：数据库表结构和数据初始化，权限配置，</p><p>特别注意生产环境上的用户数据修改，此时用户在使用，很重要！！！</p><p>故障无法重现时：</p><p><strong>1）</strong>看日志，根据日志定位原因，则在测试环境中按照日志提示构造条件相同的测试案例测试，尝试在测试环境中将问题重现。</p><p><strong>2）</strong>测试环境和配置与实际的工程环境和配置有哪些差异等等。同时主动与开发负责人、工程实施人员以及有经验的项目经理讨论，分析可能导致的原因。</p><p>测试环境ok，生产环境新增时保存失败，查看后台日志报长度溢出，数据库内容字段要求和生产环境不一致！！</p><p><strong>6.辅助工具：linux和</strong><a href="http://www.51testing.com/html/69/javascript:;" target="_blank" rel="noopener">SQL</a></p><p>linux查看日志</p><p>SQL用来筛选数据或直接进行数据修改状态，多用于集成测试过程中前后流程相连接</p><p><strong>三.浏览器兼容性和网页规范标准测试</strong></p><p>浏览器兼容性测试（偏主流浏览器，如<a href="http://www.51testing.com/html/69/javascript:;" target="_blank" rel="noopener">谷歌</a>，火狐，IE8以上）：</p><p><a href="https://dev.windows.com/en-us/microsoft-edge/tools/staticscan/" target="_blank" rel="noopener">https://dev.windows.com/en-us/microsoft-edge/tools/staticscan/</a></p><p>W3C网页验证：（判断网页书写是否符合规范，记住此处必须去掉权限控制，单个单元页面url需要跟参数）</p><p><a href="https://validator.w3.org/" target="_blank" rel="noopener">https://validator.w3.org/</a></p><p>W3C手机端页面检测（如手机微信菜单下的页面）：</p><p><a href="https://validator.w3.org/mobile-alpha/" target="_blank" rel="noopener">https://validator.w3.org/mobile-alpha/</a></p><p>互联网测试与传统测试的区别</p><p><strong>1.最大的不同：</strong>互联网产品需要自己部署和运营，用户使用瘦客户端（浏览器，app或一个需要安装的client)，核心的数据和业务逻辑在互联网公司的机房，在IDC，在云端。</p><p>如：我们做的系统用户只需一个浏览器，服务器用的阿里云，部署和运营只需要一个运维人员即可。</p><p>考虑现网（生产环境）存在下面两个问题：</p><p>（1）<a href="http://www.51testing.com/html/69/javascript:;" target="_blank" rel="noopener">如何</a>发布功能到现网</p><p>互联网测试完一般可直接发布，测试周期短，有时候需要进行灰度发布，先让部分用户用起来，发布完做生产验证。</p><p>（2）如何保证测试环境和生产环境同步</p><p>测试环境比较难搞，拿我们做的懒企鹅来说，牵扯的系统平台比较多，用到很多微信平台的接口，这个很难自己搭建或者用mock。</p><p>另外保证测试环境和到生产环境都是好的，需要代码和数据库，以及环境配置都要保持一致，这需要相应的机制和工具来验证和同步。</p><p><strong>2.互联网产品节奏很快</strong></p><p>有的软件公司，基本是进行二次开发，周期长，每次都需要经过下面几个完整的测试流程：</p><p>客户提出需求–BA和客户沟通，确定需求和解决方案–测试人员根据需求说明书和解决方案编写测试用例、进行概要评审、进行详细设计评审、开始测试、回归测试、生产验证。</p><p>现在的互联网产品测试基本为：</p><p>产品经理确定好测试需求–开发人员写详设-（此阶段可以进行设计bug检查）–开发人员开发–测试人员测试，上线</p><p>来不及测试设计，来不及自动化，短时间内如何保证测试的覆盖率和质量？–（探索式测试应势而生）</p><p><strong>3.更多的人参与到测试中</strong></p><p>互联网公司有专门的测试团队的比较少，一般开发和测试比例： 7:1，如何保证质量？</p><p><strong>1）</strong>开发人员的自测</p><p>开发人员进行<a href="http://www.51testing.com/html/69/javascript:;" target="_blank" rel="noopener">单元测试</a>，<a href="http://www.51testing.com/html/69/javascript:;" target="_blank" rel="noopener">测试用例</a>的通过率，同一个版本拉代码的次数</p><p><strong>2）</strong>产品或运营人员的体验</p><p>在这里基本我就相当于用户，进行产品体验，或者根据免费试用者反馈的意见进行优化</p><p><strong>3）</strong>发布之前的评审</p><p>注意环境，配置，数据方面的问题</p><p><strong>4.有一些是免测试的</strong></p><p>并不是所有发布到生产环境的东西都需要在测试环境检验，如：图片样式改动，小bug修复，但是哪些免测是个复杂的问题</p><p><strong>5.海量用户带来的挑战</strong></p><p><strong>1）</strong>性能方面</p><p>如何做轻量级的<a href="http://www.51testing.com/html/69/javascript:;" target="_blank" rel="noopener">性能测试</a></p><p><strong>2）</strong>浏览器的兼容性</p><p>现在的系统大多基于主流的火狐，谷歌，IE8以上，放弃浏览器兼容就等于放弃一部分客户。</p><p><strong>6.测试工具和技术方面</strong></p><p>传统的企业花钱购买商业软件，如<a href="http://www.51testing.com/html/69/javascript:;" target="_blank" rel="noopener">QTP</a>，loadrunner，或者自己开发的<a href="http://www.51testing.com/html/69/javascript:;" target="_blank" rel="noopener">项目管理</a>工具</p><p>大部分的互联网公司使用开源或自主研发的，如 selenium，appium，robotium,monkeyrunner,jmeter</p><p>相同点：</p><p>1.都需要非常熟悉产品和业务</p><p>2.都需要了解产品的技术（深度测试方面性能分析，内存泄露，web服务器，cache，代理)</p><p>3.具体的<a href="http://www.51testing.com/html/69/javascript:;" target="_blank" rel="noopener">测试技术</a></p><p>4.测试设计的方法</p><p>5.测试人员的技术体系：</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Jul 31 2020 20:37:09 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;&lt;strong&gt;一、对系统整体的了解&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;http://www.51testing.
      
    
    </summary>
    
    
      <category term="Web" scheme="http://yoursite.com/categories/Web/"/>
    
    
      <category term="learn" scheme="http://yoursite.com/tags/learn/"/>
    
  </entry>
  
  <entry>
    <title>接口测试</title>
    <link href="http://yoursite.com/2020/07/31/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/"/>
    <id>http://yoursite.com/2020/07/31/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/</id>
    <published>2020-07-31T11:25:08.000Z</published>
    <updated>2020-07-31T11:26:07.106Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Jul 31 2020 20:37:09 GMT+0800 (GMT+08:00) --><p>接口测试是测试系统组件间接口的一种测试。接口测试主要用于检测外部系统与系统之间以及内部各个子系统之间的交互点。</p><p>测试的重点是要检查数据的交换，传递和控制管理过程，以及系统间的相互逻辑依赖关系等。</p><p>​ <strong>——百度百科！</strong></p><p><strong>一、基础介绍</strong></p><p><strong>1、什么是接口</strong></p><p>我们常说的接口一般指2种<br><strong>1）API：</strong>应用程序编程接口</p><p><strong>2）GUI：</strong>图形用户界面（接口）</p><p>这里我们主要说API——接口测试</p><p><strong>2、接口测试的目的</strong></p><p>测试接口的正确性和稳定性（持续集成是接口测试的核心）</p><p><strong>3、接口测试的原理</strong></p><p>模拟客户端向服务器发送请求报文，服务器接收请求报文后对相应的报文做处理并向客户端返回应答，客户端接收应答的一个过程。</p><p><strong>4、接口测试的重点</strong></p><p>检查数据的交换，传递和控制管理过程，还包括处理的次数</p><p><strong>5、接口测试用例设计</strong></p><p>接口测试对象主要为接口，但随着系统复杂度越来越高，接口越来越多，完全覆盖是一件很困难的事情，且实际过程中任意接口的变动都可能导致我们接口测试用例不可用，</p><p>所以通常情况下主要测试最外层的两类接口:数据进入系统接口（调用外部系统的参数为本系统使用）和数据流出系统接口（验证系统处理后的数据是否正常）。</p><p>PS：设计用例时还需要注意外部接口提供给使用这些接口的外部用户什么功能，外部用户真正需要什么功能。</p><p><strong>6、接口测试的优点</strong></p><p>天生为高复杂性的平台带来高效的缺陷监测和质量监督能力；平台越复杂，系统越庞大，接口测试的效果越明显（提高测试效率，提升用户体验，降低研发成本）</p><p><strong>二、接口分类及分析方法，测试重点</strong></p><p><strong>1、功能分类</strong></p><p><strong>1）功能间接口：</strong>系统中功能模块间的接口，比如：ERP系统中采购模块和库存模块之间的接口</p><p><strong>特点：</strong>一般部署在同一个服务器中，并且使用同一个数据库</p><p><strong>测试方法：</strong>通常采用黑盒测试方法，注意接口数据在不同模块间的走向；尤其是接口间的逻辑控制关系</p><p>例如：销售发货，检查库存可用量，如可用量不足，则不允许发货</p><p><strong>2）系统间接口：</strong>不同系统间的接口，比如：银行的各个系统间的接口。核心系统和各个外围系统之间都是此类接口</p><p><strong>特点：</strong>部署在不同服务器上，不仅采用不同的数据库，而且数据库类型还有可能不同</p><p><strong>测试方法：</strong>通常采用白盒测试方法，关注系统间接口的实现方式</p><p>例如：接口文件类型、接口文件格式、接口文件处理方式等</p><p><strong>2、类型分类</strong></p><p><strong>1）业务接口：</strong>系统或功能间有业务逻辑关系，比如：ERP系统中，采购入库后，会生成库存入库单，影响可用量等，也可称为：<strong>联机接口</strong></p><p><strong>特点：</strong>接口间有业务逻辑的上下游关系，可能会涉及跨系统或者模块的逻辑控制，以及反向操作</p><p><strong>测试方法：</strong>通常黑盒测试方法，注重分析业务逻辑，采用路径覆盖法分析，重点：注意正向反向操作的测试</p><p><strong>2）数据接口：</strong>接口数据有上下游关系，比如：企业征信系统，要通过数据交换平台获取核心系统的数据，也可称为：<strong>批量接口</strong></p><p><strong>特点：</strong>系统间只存在数据的上下游关系，而且都是进行批量处理</p><p><strong>测试方法：</strong>通常采用白盒测试方法，关注数据的文件格式，以及记录数及内容是否正确，还要考虑数据加密问题</p><p><strong>3、数据方向分类</strong></p><p><strong>1）单向接口：</strong>数据在接口中是单向流动，但根据实现方式分为单项推或单项取</p><p>比如：数据仓库和各系统间的接口基本都是单项的，一方面前端系统向数据仓库推送数据，一方面后端系统从数据仓库取数据仓库提供的数据</p><p><strong>特点：</strong>不管是单向推还是单项取，都会有一个FTP地址，存放指定数据文件，并且有定时存取规则，可从日志中查看结果</p><p><strong>测试方法：</strong>通常采用黑盒白盒结合的测试方法，着重数据文件格式，是否按照规则存取等</p><p><strong>2）双向接口：</strong>两个系统间的数据有往来，比如：综合报文处理系统和核心系统，从何报文处理系统即接受核心系统发送的数据，又要将处理结果反馈给核心系统</p><p><strong>特点：</strong>可以将不同数据方向的接口分开分析，当做两个单项接口，注意来往数据通常具有关联性</p><p><strong>测试方法：</strong>通常采用黑盒白盒结合的测试方法，注重来往数据的关联性，合理设计测试数据，制定测试执行计划</p><p><strong>4、数据读写方式分类</strong></p><p><strong>1）单独读写接口：</strong>数据在接口中不仅单项流动，而且都是读或者写的单独操作，比如：前面提到的各系统和数据仓库的数据交换</p><p><strong>特点：</strong>与单项接口相似</p><p><strong>测试方法：</strong>黑盒白盒相结合的方法，注意读写的权限，以及单接口功能未正常实现时，系统是否有异常处理机制</p><p><strong>2）即读又写接口：</strong>系统间接口处理时，即读取又写入，比如：贷款合同管理和核心系统，先读取核心系统中的合同信息，添加合同成功后，又将合同编号回写到核心系统中</p><p><strong>特点：</strong>一般都是业务类接口，非数据类接口，并且都有逻辑控制的要求</p><p><strong>测试方法：</strong>通常采用黑盒测试方法，注意业务逻辑控制，不仅要检查读取的数据是否正确，还要检查回填数据是否正确</p><p><strong>5、层级分类</strong></p><p><strong>1）直接（联机）接口：</strong>系统或模块间的接口是直接联通的</p><p><strong>特点：</strong>直接联通</p><p><strong>测试方法：</strong>黑盒白盒相结合的方法，根据接口特征分析即可</p><p><strong>2）间接（非联机）接口：</strong>系统间接口不是直接联通，通过第三方中转后，才进行连接，比如：综合报文系统和核心系统，中间隔着一个ESB</p><p><strong>特点：</strong>接口间的中间层，会进行处理，才会将数据发送到接口系统，这个不会涉及业务逻辑，只是数据格式转换</p><p><strong>测试方法：</strong>黑盒白盒相结合的方法，可直接忽略中间层的存在，设计测试用例；但出现问题时，一定要注意中间层处理是否正确，并且，测试中间层异常时，系统处理是否正确</p><p><strong>三、**</strong>怎么做好接口测试**</p><p><strong>1、接口正确性是双方保障，都要进行测试</strong></p><p><strong>2、根据接口类型，合理进行测试分析，注意测试重点</strong></p><p><strong>3、注重业务逻辑分析，包括正向反向操作</strong></p><p><strong>4、注重数据文件检查</strong></p><p><strong>四、接口测试的工具</strong></p><p>可以进行接口测试的工具很多，这里简单介绍几个：</p><p><strong>1、loadrunner：</strong>一款商业性能测试工具，用来做接口测试，很好很强大</p><p><strong>2、jmeter：</strong>一款开源的性能测试工具，操作简单，方便，既有jdbc request操作数据库数据，也有http request和soap request应对测试</p><p><strong>3、poster：</strong>火狐浏览器自带接口测试工具，插件中安装即可，界面简单明了，容易上手</p><p><strong>4、postman：</strong>谷歌浏览器的扩展工具，谷歌商店中选中安装，界面同poster差别不大，界面简洁</p><p><strong>5、soapui：</strong>开源测试工具，通过soap/http来检查、调用、实现Web Service的功能/负载/符合性测试；</p><p>​ 该工具既可作为一个单独的接口测试工具使用，也可利用插件集成到Eclipse，maven2.X，Netbeans 和intellij中使用。</p><p><strong>PS：写在最后：</strong></p><p>以保证系统的正确和稳定为核心，以持续集成为手段，提高测试效率，提升用户体验，降低产品研发成本，关注持续集成是接口测试的灵魂，否则接口测试带来工作量会成指数增长！</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Jul 31 2020 20:37:09 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;接口测试是测试系统组件间接口的一种测试。接口测试主要用于检测外部系统与系统之间以及内部各个子系统之间的交互点。&lt;/p&gt;&lt;p&gt;测试的重点是要检查数
      
    
    </summary>
    
    
      <category term="Web" scheme="http://yoursite.com/categories/Web/"/>
    
    
      <category term="learn" scheme="http://yoursite.com/tags/learn/"/>
    
  </entry>
  
  <entry>
    <title>http5</title>
    <link href="http://yoursite.com/2020/07/31/http5-1/"/>
    <id>http://yoursite.com/2020/07/31/http5-1/</id>
    <published>2020-07-31T09:24:39.000Z</published>
    <updated>2020-07-31T09:24:39.526Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Jul 31 2020 20:37:09 GMT+0800 (GMT+08:00) --><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Jul 31 2020 20:37:09 GMT+0800 (GMT+08:00) --&gt;&lt;!-- rebuild by neat --&gt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>http4</title>
    <link href="http://yoursite.com/2020/07/31/http4/"/>
    <id>http://yoursite.com/2020/07/31/http4/</id>
    <published>2020-07-31T04:32:22.000Z</published>
    <updated>2020-07-31T09:22:40.486Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Jul 31 2020 20:37:09 GMT+0800 (GMT+08:00) --><p><strong>一：http状态码</strong></p><p>表示客户端http请求的返回结果、标记服务器端的处理是否正常、通知出现的错误等工作</p><p>状态码的类别如下：</p><p><img src="983980-20160720103537747-659231225.png" alt="img"></p><p>http状态码种类繁多，大概有60多种，实际上经常使用的只有14种，下面为一一介绍</p><p><strong>1、2XX 成功：</strong>请求被正常处理</p><p>1.1 200 OK</p><p>表示从客户端发来的请求在服务器端被正常处理</p><p>1.2 204 No Content</p><p>表示服务器接收的请求以成功处理，但没有资源可返回，即：响应报文中不含实体的主体部分</p><p>1.3 206 Partial Content</p><p>表示客户端进行了范围请求且服务器成功执行了这部分的GET请求，响应报文中包含由Content_Range指定范围的实体内容</p><p>“Content_Range为请求首部的一种类型，后面的随笔会讲到”</p><p><strong>2、3XX 重定向：</strong> 服务器需要执行某些特殊处理以正确处理请求（即URI地址或者资源的缓存的资源有效时间过期）</p><p>2.1 301 Moved Permanently</p><p>永久性重定向：表示请求的资源已被分配了新的URI，以后应使用资源现在的URI，如果已经保存了书签，这时候应该按照Location首部提示的URI重新保存</p><p>2.2 302 Found</p><p>临时性重定向：表示请求的资源已被分配到了新的URI，希望（本次）能使用新的URI访问</p><p>2.3 303 See Other</p><p>表示请求对应的资源存在另一个URI,应该使用GET方法定向获取请求的资源</p><p><strong>PS：</strong>当301、302、303响应状态码返回，几乎所有浏览器都会把POST改成GET，并删除请求报文内的主体，之后请求自动再次发送</p><p>301、302标准禁止将POST改为GET，但实际中都会允许这么做<del>~</del>GG</p><p>2.4 304 Not Modified</p><p>表示客户端发送得<strong>附带条件</strong>的请求时，服务器运行请求访问，但未满足条件的情况，304返回时，不包含任何响应的主体部分</p><p><strong>附带条件：</strong>采用GET方法的请求报文中包含If-……条件的任一首部，后面的随笔中介绍</p><p>2.5 307 Temporary Redirect</p><p>临时重定向：禁止将POST转换为GET，该状态码会严格遵守浏览器标准</p><p><strong>3、客户端错误：</strong>4XX的响应结果表明客户端是发生错误的原因所在</p><p>3.1 400 Bad Ruquest</p><p>请求报文存在语法错误</p><p>3.2 401 Unauthorized</p><p>发送的请求需要有通过http认证（BASIC认证、DIGEST认证）的认证信息</p><p><strong>PS：</strong>若之前已经进行了一次请求，则表示用户认证失败</p><p>​ 返回含有401的响应必须包含一个适用于被请求资源的WWW-Authenticate首部用来质询用户信息</p><p>3.3 403 Forbidden</p><p>对请求资源的访问被服务器拒绝（服务端没有必要给出拒绝的详细理由，如果想做说明，可在实体主体部分对原因进行描述）</p><p><strong>举例：</strong>未获得文件系统的访问授权、访问权限出现某些问题等</p><p>3.4 404 Not Found</p><p>服务器上无法找到请求的资源</p><p><strong>4、 5XX服务器错误：</strong>服务器本身发生错误</p><p>4.1 500 Internal Server Error</p><p>服务器端执行请求时发生错误</p><p>4.2 503 Server Unavailable</p><p>服务器暂时处于超负载或者正在停机维护，现在无法处理请求</p><p><strong>1、http1.1规范允许一台http服务器搭建多个web站点。。。</strong></p><p>比如提供web托管服务的供应商，可以用一台服务器为多为客户服务，也可以以每位客户持有的域名运行各自不同的网站，这里利用了虚拟服务器的功能。。。</p><p>客户端使用http协议访问服务器时，会经常采用类似<a href="http://www.baidu.con这样的主机名和域名" target="_blank" rel="noopener">www.baidu.con这样的主机名和域名</a></p><p>在互联网上，域名通过DNS服务映射到IP地址之后访问目标网站，可见，请求发送到服务器时，已经是以IP地址形式访问</p><p>所以，如果一台服务器内托管了<a href="http://www.baidu.com和www.sina.com这两个域名，收到请求时就需要搞清楚究竟要访问哪个域名" target="_blank" rel="noopener">www.baidu.com和www.sina.com这两个域名，收到请求时就需要搞清楚究竟要访问哪个域名</a></p><p>在相同的IP地址下，发送请求时，必须在Host首部内完成指定主机名或者域名的URI。</p><p>web服务器</p><p><strong>2、通信数据的转发程序</strong></p><p>http通信时，出客户端和服务器外，还有一些用于通信数据转发的应用程序，比如<strong>代理、网关、隧道</strong></p><p><strong>2.1 代理：</strong>具有转发功能的应用程序</p><p>扮演了客户端和服务器“中间人”的角色，接受请求并转发给服务器，同时也接受响应并返回给客户端</p><p>代理不会改变URI，会直接将请求发送给持有资源的源服务器，然后响应通过代理服务器后再传给客户端</p><p>http通信中，可以级联多台代理服务器，每次通过代理服务器转发请求和响应时，会追加写入Via首部信息，以标记出经过的主机信息</p><p><strong>代理服务器的优点：</strong>利用缓存技术（下文）减少网络带宽流量，组织内部针对特定网站的访问控制，获取访问日志为主要目的等</p><p>缓存代理：预先将资源的副本缓存在代理服务器上，再次受到对相同资源的请求时，可以将自己的缓存返回</p><p>透明代理：转发请求或者响应时，不对报文做任何加工的代理类型</p><p><strong>2.2 网关：</strong>转发其他服务器通信数据的服务器</p><p>接受客户端发来的请求，就像自己拥有资源的服务器一样处理请求</p><p>网关的工作机制与代理什么类似，而网关可以使通信线路上的服务器提供非http协议服务</p><p><strong>特点：</strong>提高通信安全性，可以在客户端和网关之间通信线路上加密以确保连接安全。</p><p><strong>2.3 隧道：</strong>在客户端和服务器之间进行中转，并保持双方通信连接的应用程序</p><p><strong>特点：</strong>可以使用SSL等加密手段进行通信，确保客户端能与服务器进行安全的通信</p><p><strong>3、资源的缓存</strong></p><p>缓存是指代理服务器或者客户端本地磁盘内保存的资源副本。</p><p>利用缓存可减少对源服务器的访问，节省通信流量和通信时间。</p><p><strong>3.1 缓存的有效期</strong></p><p>当源服务器的资源更新时，或者因为客户端要求，缓存的有效时间等因素，都需要向源服务器确认有效性，如果缓存失效，缓存服务器将再次向源服务器获取最新的资源</p><p><strong>3.2 客户端的缓存</strong></p><p>缓存不仅可以存与代理服务器内，还可以存在客户端浏览器中。如果缓存有效，就可以直接从本地磁盘中读取资源</p><p>同样，当缓存过期，还是需要向源服务器请求资源</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Jul 31 2020 20:37:09 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;&lt;strong&gt;一：http状态码&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;表示客户端http请求的返回结果、标记服务器端的处理是否正常、通知出现的错误等
      
    
    </summary>
    
    
      <category term="Web" scheme="http://yoursite.com/categories/Web/"/>
    
    
      <category term="learn" scheme="http://yoursite.com/tags/learn/"/>
    
  </entry>
  
  <entry>
    <title>http5</title>
    <link href="http://yoursite.com/2020/07/31/http5/"/>
    <id>http://yoursite.com/2020/07/31/http5/</id>
    <published>2020-07-31T04:29:57.000Z</published>
    <updated>2020-07-31T12:36:43.556Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Jul 31 2020 20:37:09 GMT+0800 (GMT+08:00) --><p>http请求和响应报文内容比较多，会分为大概四部分更新，最近比较忙，没太多时间整理- -</p><p>报文首部</p><p>首先来看看报文结构吧</p><p><img src="983980-20160726170327169-2052933884.png" alt="img"></p><p><strong>1、http请求报文</strong></p><p>http请求报文由方法、URI、http版本。http首部字段等构成</p><p><img src="983980-20160726172807200-749499171.png" alt="img"></p><p>下面给大家示例一个访问my_view_page.php的请求报文首部信息</p><p>GET /my_view_page.php HTTP/1.1</p><p>Host: 10.0.17.183:8000</p><p>Connection: keep-alive</p><p>Cache-Control: max-age=0</p><p>Upgrade-Insecure-Requests: 1</p><p>User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36</p><p>Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,<em>/</em>;q=0.8</p><p>Referer: <a href="http://10.0.17.183:8000/my_view_page.php" target="_blank" rel="noopener">http://10.0.17.183:8000/my_view_page.php</a></p><p>Accept-Encoding: gzip, deflate, sdch</p><p>关于报文的首部信息，稍微详解</p><p><strong>2、http响应报文</strong></p><p>http响应报文由http版本、状态码（数字和原因短语）、http首部字段3部分组成</p><p><img src="983980-20160726175828981-742252783.png" alt="img"></p><p>以下是刚才访问my_view_page.php时服务器返回的响应报文首部信息：</p><p>HTTP/1.1 200 OK</p><p>Cache-Control: no-store, no-cache, must-revalidate</p><p>Date: Tue, 26 Jul 2016 09:32:11 GMT</p><p>Expires: Tue, 26 Jul 2016 09:32:12 GMT</p><p>Vary: Accept-Encoding</p><p>Content-Encoding: gzip</p><p>Content-Length: 3892</p><p>Content-Type: text/html; charset=utf-8</p><p>Last-Modified: Tue, 26 Jul 2016 09:32:12 GMT</p><p>报文中含有众多的字段，其中又以http首部字段内容最丰富，其同时存在于请求和响应中，并涵盖http报文相关的内容</p><p><strong>3、http首部字段</strong></p><p>定义：构成http报文的要素之一，在客户端与服务器之间以http协议传输信息的过程中，起到传递额外重要信息的作用</p><p><strong>3.1首部字段结构</strong></p><p>首部字段名：字段值</p><p>例如：以Content-Type来表示报文主体的对象类型</p><p>Content-Type：text/html</p><p>另外，字段值对应的单个http首部字段可以有多个值，比如</p><p>Keep-Alive:timeout=15,max=100</p><p><strong>3.2 4种http首部字段类型</strong></p><p>http1.1规范了47种首部字段</p><p><strong>3.2.1 通用首部字段</strong></p><p>定义：请求和响应报文都会使用的首部</p><p><img src="983980-20160728175645419-1195774829.png" alt="img"></p><p><strong>3.2.2 请求首部字段</strong></p><p>从客户端向服务器发送请求报文时使用的首部，补充了请求的附加内容、客户端信息、相应内容相关优先级信息</p><p><img src="983980-20160728181220403-694647616.png" alt="img"></p><p><strong>3.2.3 响应首部字段</strong></p><p>从服务器向客户端返回响应报文时使用的首部。补充了资源内容更新时间等与实体有关的信息</p><p><img src="983980-20160728182829888-1176922655.png" alt="img"></p><p><strong>3.2.4 实体首部字段</strong></p><p>针对请求报文和响应报文的实体部分使用的首部，补充了资源内容更新时间与实体有关的信息</p><p><img src="983980-20160728184346169-2022295186.png" alt="img"></p><p><strong>3.2.5 End-to-end首部和Hop-by-hop首部</strong></p><p>http首部字段将定义成缓存代理和非缓存代理的行为，分成2种类型</p><p><strong>端到端首部（End-to-end Header）</strong></p><p>此类别中的首部会转发给请求/响应对应的最终接受目标，而且必须保存在由缓存生成的响应中，另外规定它必须被转发。</p><p><strong>逐跳首部（Hop-by-hop Header）</strong></p><p>此类别中的首部只对单次转发有效，会因通过缓存或代理而不再转发；http1.1和之后的版本，如要使用该首部，需提供Connection首部字段。</p><p>下面列举下http/1.1中的逐跳首部字段，除了这8个，其他所有字段都属于端到端首部。</p><p>Connection:</p><p>Keep-Alive</p><p>Proxy-Authenticate</p><p>Proxy-Authorization</p><p>Trailer</p><p>TE</p><p>Transfer-Encoding</p><p>Upgrade</p><p><strong>通用首部字段</strong></p><p>通用首部字段的意思，就是：请求和响应报文双方都会使用的首部</p><p><strong>1、Cache-Control</strong></p><p>通过指定它的指令，能操作缓存的工作机制</p><p>指令参数是可选的，多个指令通过“，”分隔</p><p>Cache-Control: private, max-age=0, no-cache</p><p>Cache-Control指令一览：</p><p><strong>1.1 缓存请求指令</strong></p><table><thead><tr><th>指令</th><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>no-cache</td><td>无</td><td>强制向源服务器再次验证</td></tr><tr><td>no-store</td><td>无</td><td>不缓存请求或相应的任何内容</td></tr><tr><td>max-age[秒]</td><td>必须</td><td>相应的最大Age值</td></tr><tr><td>max-stale(=[秒])</td><td>可省略</td><td>接收已过期的响应</td></tr><tr><td>min-fresh=[秒]</td><td>必须</td><td>期望在指定时间内的响应仍有效</td></tr><tr><td>no-transform</td><td>无</td><td>代理不可更改媒体类型</td></tr><tr><td>only-if-cached</td><td>无</td><td>从缓存获取资源</td></tr><tr><td>cache-extension</td><td></td><td>新标记指令（token{-}）</td></tr></tbody></table><p><strong>1.2 缓存响应指令</strong></p><table><thead><tr><th>指令</th><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>public</td><td>无</td><td>可向任意方提供响应的缓存</td></tr><tr><td>private</td><td>可省略</td><td>仅向特定用户返回响应</td></tr><tr><td>no-cache</td><td>可省略</td><td>缓存前必须先确认其有效性</td></tr><tr><td>no-store</td><td>无</td><td>不缓存请求或响应的任何内容</td></tr><tr><td>no-transform</td><td>无</td><td>代理不可更改媒体类型</td></tr><tr><td>must-revalidate</td><td>无</td><td>可缓存但必须再向源服务器进行确认</td></tr><tr><td>proxy-revalidate</td><td>无</td><td>要求中间缓存服务器对换缓存的响应有效性再次确认</td></tr><tr><td>max-age=[秒]</td><td>必需</td><td>响应的最大Age值</td></tr><tr><td>s-maxage=[秒]</td><td>必需</td><td>公共缓存服务器响应的最大Age值</td></tr><tr><td>cache-extension</td><td></td><td>新指令标记（token{-}）</td></tr></tbody></table><p><strong>1.3 public</strong></p><p>共享、公开的缓存状态，与private相反</p><p>Cache-Control: public</p><p><strong>1.4 private</strong></p><p>指定缓存对象，需要验证</p><p>Cache-Control: private</p><p><strong>1.5 no-cache</strong></p><p>防止从缓存中返回过去的资源，请求中如包含该命令，表示客户端不会接收缓存过的响应，必须向源放武器转发请求</p><p>如果响应中包含该命令，那么缓存服务器不能对其资源进行缓存，且源服务器也将不在对缓存服务器请求中提出的资源有效性进行确认，且禁止其对相应资源进行缓存操作</p><p>Cache-Control: no-cache=Location</p><p>由服务器返回的响应报文首部字段中，若Cache-Control中对no-cache字段名具体制定参数值，那么客户端在收到这个被指定参数值的首部字段对应的报文后，就不能缓存</p><p>换言之，无参数值的首部字段可以使用缓存，只能在响应中制定该参数</p><p><strong>1.6 no-store</strong></p><p>请求中包含机密信息，缓存不能在本地存储请求或响应的任一部分k</p><p>Cache-Control: no-store</p><p><strong>1.7 s-maxage</strong></p><p>一般指代理服务器</p><p>与max-age指令相同，不同点在于s-maxage只适用于供多位用户使用的公共缓存服务器</p><p>当使用该指令时，直接忽略对Expires首部字段及max-age指令的处理</p><p>Cache-Control: s-maxage=604800（单位：秒）</p><p><strong>1.8 max-age</strong></p><p>缓存资源缓存时间数值低于指定数值，就接受缓存的资源，如max-age为0，则需要请求源服务器</p><p>http1.1中，如遇到存在Expires首部字段的情况，会忽略Expires字段，优先处理max-age指令</p><p>Cache-Control: max-age=604800（单位：秒）</p><p><strong>1.9 min-fresh</strong></p><p>要求缓存服务器返回未过指定时间的资源</p><p>Cache-Control: min-fresh=60（单位：秒）</p><p><strong>1.10 max-stale</strong></p><p>规定缓存的有效期，如指令中没有参数，则无论多久，客户端都可以接受响应，如指定了参数，即使过了有效期，只要在指令的范围内，客户端都可以接受响应</p><p>Cache-Control: max-stale</p><p><strong>1.11 only-if-cached</strong></p><p>表示客户端只在缓存服务器有对应资源的情况下才接受响应，若无，则返回504</p><p>Cache-Control: only-if-cached</p><p><strong>1.12 must-revalidate</strong></p><p>代理向客户端返回响应前再次向源服务器确认资源的有效性，若无，则返回504，且该指令会忽略请求中的max-stale指令</p><p>Cache-Control: must-revalidate</p><p><strong>1.13 proxy-revalidate</strong></p><p>要求所有的缓存服务器在向客户端返回响应之前再次向源服务器确认资源的有效性</p><p>Cache-Control: proxy-revalidate</p><p><strong>1.14 no-transform</strong></p><p>要求无论请求还是响应，都不能改变实体主体的媒体类型，防止缓存或者代理压缩图片等操作</p><p>Cache-Control: no-transform</p><p><strong>2、Connection</strong></p><p>该首部字段具备下面2个作用</p><p><strong>1）控制不再转发给代理的首部字段</strong></p><p>Connection:不再转发的字段名（即删除后再转发）</p><p><strong>2）管理持久连接</strong></p><p>http1.1默认都是持久连接，客户端会在持久连接上持续发送请求，当服务器明确表示需要断开连接时，则指明首部字段值为close</p><p>Connection: close</p><p>http1.1之前的版本默认都是非持久连接，需要在旧版本上保持持久连接，需要加入Keep-Alive指令</p><p>Connection-Keep-Alive</p><p><strong>3、Date</strong></p><p>表明创建http报文的日期和时间</p><p>目前http1.1版本使用如下格式的时间：</p><p>Date: Sun, 31 Jul 2016 01:28:48 GMT</p><p><strong>4、Pragma</strong></p><p>是http1.1之前的版本历史遗留字段，仅作为与http1.0的向后兼容而定义，规范定义的形式唯一，如下所示</p><p>Pragma: no-cache</p><p>只用于客户端发送的请求中，客户端要求所有的中间服务器不返回缓存的内容</p><p><strong>5、Trailer</strong></p><p>事先说明在报文主体后记录了哪些首部字段，可应用于http1.1版本分块传输编码时</p><p><strong>6、Transfer-Encoding</strong></p><p>规定报文主体的编码方式</p><p>http1.1的传输编码方式仅对分块传输编码有效</p><p>Transfer-Encoding: chunked</p><p><strong>7、Upgrade</strong></p><p>检测http协议及其他协议是否可使用更高的版本进行通信，其参数值可用来指定一个完全不同的通信协议</p><p>客户端请求：</p><p>GMT /index.htm HTTP/1.1</p><p>Upgrade: TLS/1.0</p><p>Connection: Upgrade</p><p>服务器响应:</p><p>HTTP/1.1 101 Switching Protocols</p><p>Upgrade: TLS/1.0, HTTP/1.1</p><p>Connection: Upgrade</p><p>上面的例子中，首部字段Upgrade指定的值为TLS/1.0，这里的两个首部字段的对应关系，Connection的值被指定为Upgrade。</p><p>Upgrade对象仅限于客户端和邻近服务器之间，因此，使用首部字段Upgrade时，还需要额外指定Connection Upgrade</p><p>对于附有首部字段Upgrade的请求，服务器可以用101Switch Protocols状态码作为响应返回</p><p><strong>8、Via</strong></p><p>使用首部字段Via是为了追踪客户端与服务器间的请求和响应报文的传输路径</p><p>Via不仅用于追踪报文的转发，还可避免请求回环的发生，因此，必须在经过代理时附加该首部字段内容</p><p><strong>9、Warning</strong></p><p>告知用户与一些与缓存相关的问题的警告</p><p>Warning的首部格式如下，日期部分可省略</p><p>Warning：[警告码] [警告的主机：端口号] “[警告内容]” （[日期时间]）</p><p>http1.1中定义了7中警告，警告码对应的警告内容仅供参考</p><p>另外，警告码具备扩展性，今后有可能追加新的警告</p><p><img src="983980-20161223180041136-580126060.png" alt="img"></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Jul 31 2020 20:37:09 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;http请求和响应报文内容比较多，会分为大概四部分更新，最近比较忙，没太多时间整理- -&lt;/p&gt;&lt;p&gt;报文首部&lt;/p&gt;&lt;p&gt;首先来看看报文结构吧
      
    
    </summary>
    
    
      <category term="Web" scheme="http://yoursite.com/categories/Web/"/>
    
    
      <category term="learn" scheme="http://yoursite.com/tags/learn/"/>
    
  </entry>
  
  <entry>
    <title>app测试简单总结</title>
    <link href="http://yoursite.com/2020/07/31/app%E6%B5%8B%E8%AF%95%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2020/07/31/app%E6%B5%8B%E8%AF%95%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93/</id>
    <published>2020-07-31T04:21:10.000Z</published>
    <updated>2020-07-31T04:22:57.492Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Jul 31 2020 20:37:09 GMT+0800 (GMT+08:00) --><p><strong>1、安全测试（权限）</strong></p><p>1）软件权限：其中包括发送信息，拨打电话，链接网络，访问手机信息，联系人信息等等</p><p>2）数据在本地的存储、传输等</p><p>3）执行某些操作时导致的输入有效性验证、授权、数据加密等方面</p><p>4）基于各种通信协议或者行业标准来检查</p><p><strong>2、安装运行卸载测试</strong></p><p>1）验证app能否正确安装运行卸载，以及操作过程和操作前后对系统资源的占有情况</p><p>2）安装运行卸载的提示，报告等</p><p>3）检查安装路径，文件是否合理，组件是否正确注册等</p><p><strong>3、UI测试</strong></p><p>1）用户界面（菜单、对话框、窗口）等布局，风格是否满足用户需求，文字位置，描述是否正确，界面美观程度，文字图片组合是否合理</p><p>2）用户友好性、人性化、便于操作等</p><p><strong>4、功能测试</strong></p><p>1）评审需求，多方面考虑，整理出内在外在以及非功能性的直接间接功能点，对比需求，提取测试点</p><p>2）根据常用的一些分析方法，等价类边界值判定表因果图场景法等方法，设计测试用例，对提取的功能点进行覆盖</p><p>3）测试各个阶段不断跟踪缺陷，做好用例的更新迭代和不断变更需求所带来的业务或者需求的错误</p><p><strong>5、性能测试</strong></p><p>1）极限测试：各种边界情况下验证app的响应能力</p><p>如：低电量、储存满。弱网等情况</p><p>2）响应能力测试：验证各种情况下不同操作能否满足用户响应需求</p><p>3）压力测试：反复长期操作下，系统该资源的使用情况</p><p><strong>6、中断测试（干扰）</strong></p><p>比如：前后台运行时来电话，短信，下载文件，听音乐看电影等不同情况下的表现</p><p><strong>7、兼容测试</strong></p><p>1）不同网络环境（WiFi、2G、3G、4G等）</p><p>2）各种设备品牌机型系统版本等兼容</p><p>苹果、安卓（不同品牌，不同安卓系统版本）等</p><p><strong>8、回归测试</strong></p><p>bug修复后的回归测试，上线交付前进行全部的回归，验证</p><p><strong>9、升级更新测试</strong></p><p>每次app版本迭代更新时，配合不同网络环境，及不同更新权限（强制更新，不强制更新），进行下载、安装、更新、启动运行等测试</p><p><strong>10、支付测试</strong></p><p>1）支付结果的确认，数据库查询</p><p>2）请求报文是否加密</p><p>3）不同场景的支付</p><p>金额足够、金额不足、重复支付、无网支付、弱网支付、同账号多平台一起支付、余额宝微信信用卡等多种支付方式、不同支付方式的组合、密码正确/错误、支付上限等情况</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Jul 31 2020 20:37:09 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;&lt;strong&gt;1、安全测试（权限）&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;1）软件权限：其中包括发送信息，拨打电话，链接网络，访问手机信息，联系人信息
      
    
    </summary>
    
    
      <category term="Web" scheme="http://yoursite.com/categories/Web/"/>
    
    
      <category term="learn" scheme="http://yoursite.com/tags/learn/"/>
    
  </entry>
  
  <entry>
    <title>http3</title>
    <link href="http://yoursite.com/2020/07/31/http%E5%8D%8F%E8%AE%AE%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://yoursite.com/2020/07/31/http%E5%8D%8F%E8%AE%AE%EF%BC%88%E4%B8%89%EF%BC%89/</id>
    <published>2020-07-31T02:33:12.000Z</published>
    <updated>2020-07-31T04:25:36.061Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Jul 31 2020 20:37:09 GMT+0800 (GMT+08:00) --><p>说说http协议的一些特点：</p><p><strong>1）无状态</strong></p><p>http协议是一种自身不对请求和响应之间的通信状态进行保存的协议，即无状态协议。</p><p>这种设置的好处是：更快的处理更多的请求事务，确保协议的可伸缩性</p><p>不过随着web的不断发展，有时候，需要将这种状态进行保持，随即，就引入了cookie技术，cookie技术通过在请求和响应报文中写入cookie信息来控制客户端的状态。</p><p>有关cookie的内容后面我们再说。。。</p><p><strong>2）持久性</strong></p><p>正常在发送http时，都需要建立TCP的连接，再发送报文。</p><p><img src="983980-20160630175843687-83562174.png" alt="img"></p><p>如果每次想要发送http报文都需要经过这个过程，那么时间大部分都会消耗在建立和断开连接的过程中。</p><p>因此http中使用了connection属性，用于指定连接的方式。</p><p>当设置成keep-alive，http就会建立一条持久化的连接，不需要每次都建立连接，再中断。</p><p>这样做的好处是：减轻了服务器端的负载，减少开销的那部分时间，使http请求和响应都能更快的结束，相应的，web页面显示速度也就相对提升了。</p><p><strong>3）管线化</strong></p><p>如果一个http请求，请求了大量的图片等大文件，那么其他的http请求怎么办呢？</p><p>现在，管线化技术的出现，使得http请求比持久性连接更要快；特点在于：请求数越多，时间差越明显。</p><p><strong>4）内容编码</strong></p><p>由于某些报文的内容过大，因此在传输时，为了减少传输的时间，会采取一些压缩的措施。</p><p>例如上面的报文信息中，Accept-Encoding就定义了内容编码的格式：gzip</p><p>有下面几种方式：</p><p>gzip：GNU压缩格式</p><p>compress：UNIX系统的标准压缩格式</p><p>deflate：是一种同时使用了LZ77和哈弗曼编码的无损压缩格式</p><p>identity：不进行压缩</p><p><strong>5）多部分对象集合</strong></p><p>有的时候传输的内容，不仅仅是一些字符串，还有可能是一些图片，字符，音乐二进制等混杂的内容。</p><p>这就需要使用多部分对象集合，multipart，例如在使用java编写web上传文件的代码时，需要在form中指定form的编码格式。</p><p>设置form的enctype属性的值为multipart/form-data。</p><p>这是因为默认的情况下form使用的编码格式是：applicatin/x-www-form-urlencoded，这种编码格式会把所有的内容进行编码，不适合上传文件这种情况。</p><p>这两种编码格式的区别主要是：</p><p>multipart/form-data 会以控件为基准，编码form中的内容。</p><p>application/x-www-form-urlencoded 会把form中的内容编码成键值对的形式。</p><p><strong>6）范围请求</strong></p><p>有些场景下，http报文请求一些很大的图片，但是加载过程很慢。</p><p>比如我们登录一些大图片的网址，会发现有时候图片是一块一块加载的。</p><p>这就是因为设置了http请求的长度，这样就可以分块的加载资源文件。</p><p>在请求报文中使用Range属性，在响应报文中使用Content-Type属性都可以指定一定字节范围的http请求。</p><p>接下来，说说几种http协议的数据传输方式</p><p>http协议的传输方式有很多种，处于安全考虑，常用的一般都是GET和POST两种，先来介绍下这两种</p><p>1）GET：获取资源</p><p>GET方法用来请求访问已被URL识别的资源</p><p>2）POST：传输实体主体</p><p>POST方法用来请求服务器传输信息实体的主体</p><p><strong>GET和POST的区别：</strong></p><p>首先，使用目标不同：GET方法只是用来查询，不会对浏览器上的信息产生影响，每次GET的方法都是相同的</p><p>其次，大小不同：GET是放在URL首部，因此大小随着浏览器而定，而POST则是在报文中，只要没有具体限制，文件的大小是没限制的</p><p>然后，安全性不同：GET采用的是明文传输，而POST是放在报文内部，无法看到</p><p>从使用场景的角度来说，一般像用户注册登录这种信息都是私密的，采用POST，而针对查询等，为了快速，大多采用GET传输。</p><p>（关于关于GET和POST的区别，最近重新看了很多别人写的博客啊资料什么的，发现上面的解释比较模糊，我就在下面的评论区里面将区别清晰的描述一下，当然，后面的博客也会详细的解释）</p><p>接下来介绍其他几种数据传输方式：</p><p>3）PUT：传输文件</p><p>PUT要求在请求报文的主体中包含文件内容，然后保存到请求URL指定的位置</p><p>处于安全考虑，一般web网站不使用此方法，若配合web的安全验证机制，或者架构采用REST标准的网站，就可能开放使用此方法</p><p>4）HEAD：获得报文首部</p><p>HEAD和GET方法一样，只不过不返回报文主体部分，用于确认URI的有效性及资源更新的日期时间等</p><p>5）DELETE：删除文件</p><p>DELETE是与PUT相反的方法，是按请求URI删除指定的资源</p><p>处于安全考虑，一般web网站不使用此方法，若配合web的安全验证机制，或者架构采用REST标准的网站，就可能开放使用此方法</p><p>6）OPTIONS：询问支持的方法</p><p>用来查询针对请求URI指定的资源支持的方法</p><p>7）TRACE：追踪路径</p><p>是让web服务器端将之前的请求通信还回给客户端的方法</p><p>发送请求时，在Max-Frowards首部字段中填入数值，每经过一个服务器端就-1，当数值为0时，停止传输，最后收到服务器返回状态码200 OK的响应</p><p>但是，这种方法基本很少使用，而且很容易引起XST（跨站追踪）攻击，就更不会用到了。</p><p>8）CONNECT：要求采用隧道协议连接代理</p><p>该方法要求在于代理服务器通信时建立隧道，实现用隧道协议进行TCP通信，主要使用SSL（安全套接层）和TLS（传输层安全）协议把通信内容加密后经过网络传输。</p><p>最后，附上一张http1.1和http1.0版本各自支持的方法，另外，注意用大写。。。。。。</p><p><img src="983980-20160630184847546-795504173.png" alt="img"></p><p>其中，LINK和UNLINK已被HTTP1.1废弃</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Jul 31 2020 20:37:09 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;说说http协议的一些特点：&lt;/p&gt;&lt;p&gt;&lt;strong&gt;1）无状态&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;http协议是一种自身不对请求和响应之间的通
      
    
    </summary>
    
    
      <category term="Web" scheme="http://yoursite.com/categories/Web/"/>
    
    
      <category term="learn" scheme="http://yoursite.com/tags/learn/"/>
    
  </entry>
  
  <entry>
    <title>web测试2</title>
    <link href="http://yoursite.com/2020/07/30/web%E6%B5%8B%E8%AF%952/"/>
    <id>http://yoursite.com/2020/07/30/web%E6%B5%8B%E8%AF%952/</id>
    <published>2020-07-30T10:29:19.000Z</published>
    <updated>2020-07-31T02:29:06.841Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Jul 31 2020 20:37:09 GMT+0800 (GMT+08:00) --><p><strong>一、输入框测试</strong></p><p>在web测试中，我们经常遇到这种输入框的测试，输入框测试看似简单，实际上包含了很多的测试基本的方法，思考逻辑，下面就是我总结出来的一些注意点：</p><p>​ 1）验证输入输出信息的一致性</p><p>​ 2）输入框前面的文字提示是否正确</p><p>​ 3）对特殊字符的处理、识别：单双引号，括号，逗号、分号等等，以及大小写状态，半角全角状态下的情况</p><p>​ 4）输入框的大小、长度、边框等</p><p>​ 5）不同字符的输入，以及字符组合情况的处理（数字+字母+字符等）</p><p>​ 6）对空格、tab换行键的处理机制</p><p>​ 7）密码输入框字符星号或者其他星号的转行，加密</p><p>​ 8）输入框输入字符长度是否有限制</p><p>​ 9）字符本身显示的颜色，规格等</p><p>​ 10）有些输入框需要加以限制，如输错，是否有提示？提示是否简单合理？</p><p>​ 11）输入状态，某种情况下输入框出于不可编辑，当再次处于编辑状态，输入框的输入状态是否有变化？</p><p>​ 12）输入类型：是否允许复制黏贴剪切等输入操作</p><p>​ 13）关键字是否支持通配符，以及关键字的搜索能力，敏感字等情况</p><p>​ 14）输入框输入空格的情况</p><p>​ 15）比如登陆注册，各项输入条件的判定：是否输入，输入是否正确等</p><p><strong>二、用户权限测试</strong></p><p>​ 用户权限，顾名思义，就是该账号拥有哪些执行操作的权利</p><p>​ 1）给某账号赋予权限后，登陆该账号，查看是否拥有已赋予的权限，以及权限设置是否正确（权限是否超过或者不足）</p><p>​ 2）删除或修改已经登陆并且正在执行操作的账号权限，程序能否正确处理，验证</p><p>​ 3）重新注册系统变更登陆身份后再登陆，程序能否正确执行，之前所拥有的权限能否继续使用</p><p>​ 4）在用工作分配或者角色管理情况下，删除包含用户的工作组或者角色，程序能否正确处理</p><p>​ 5）不同权限账号登陆同一个系统，权限范围是否正确</p><p>​ 6）能否给信息为空、长用户名的账号添加权限</p><p>​ 7）是否允许删除系统管理员或者修改管理员权限？删除或者修改后的实际情况</p><p>​ 8）已登录的用户能否修改或者删除自己或者他人的权限，信息</p><p>​ 9）添加用户（有编号或者标识），不同用户名标识的组合情况下，权限能否处理正确</p><p>​ 10）修改用户权限或者信息后，对其他模块是否有影响</p><p>​ 11）如果修改用户信息为和已存在的其他用户信息相同，能否修改成功？是否有对应提示？</p><p>​ 12）修改某些设置，是否会对与该账号权限相同或者高于/低于该账号的其他账号的权限造成影响</p><p>​ 13）同一用户是否可以同时属于其他组，各个组的权限能否交叉？</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Jul 31 2020 20:37:09 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;&lt;strong&gt;一、输入框测试&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;在web测试中，我们经常遇到这种输入框的测试，输入框测试看似简单，实际上包含了很多
      
    
    </summary>
    
    
      <category term="Web" scheme="http://yoursite.com/categories/Web/"/>
    
    
      <category term="learn" scheme="http://yoursite.com/tags/learn/"/>
    
  </entry>
  
  <entry>
    <title>web测试</title>
    <link href="http://yoursite.com/2020/07/30/web%E6%B5%8B%E8%AF%95/"/>
    <id>http://yoursite.com/2020/07/30/web%E6%B5%8B%E8%AF%95/</id>
    <published>2020-07-30T02:30:35.000Z</published>
    <updated>2020-07-30T03:47:16.214Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Jul 31 2020 20:37:09 GMT+0800 (GMT+08:00) --><p><strong>一、功能测试</strong></p><p>​ <strong>1.1链接测试</strong></p><p>​ 链接是web应用系统的一个很重要的特征，主要是用于页面之间切换跳转，指导用户去一些不知道地址的页面的主要手段，链接测试一般关注三点：</p><p>​ 1）链接是否按照既定指示那样，确实链接到了该链接的界面</p><p>​ 2）测试该链接所链接的页面是否真的存在</p><p>​ 3）保证系统中没有单独存在的页面（即没有链接指向，只能通过正确的URL地址才能访问）</p><p>​ PS：这里顺带说点关于协议的一些小知识，URL全称“统一资源定位符”，表示获取某一互联网资源的地址；而URI表示“统一资源标识符”，代表互联网上某一些资源</p><p>​ <strong>1.2表单测试</strong></p><p>​ 这个也可以理解为数据落地；当用户在web应用系统上向服务器提交信息时，就需要使用表单操作，比如，用户注册，登录，信息变更等等；这种情况下，我们必须测试提交信息的完整性，</p><p>​ 以检验提交给服务器的数据的正确性，当然，这涉及到一些常理性逻辑，比如：出生日期和职业，工作年限是否恰当，所在地省份城市区域间的匹配等，如果设定使用默认值，也需要测试。</p><p>​ <strong>1.3导航测试</strong></p><p>​ 作为测试，很多时候都要站在用户的角度去思考，那么，作为一个用户，当他访问一个web的网站或者系统时，会怎么去操作呢？</p><p>​ 大部分用户都是目的驱动的，当他访问一个网站，会很快的浏览系统，找不到满足自己需求的信息时，会很快离开，很少有用户愿意花时间去熟悉系统的结构，因此，导航测试就显得很重要。</p><p>​ 导航测试，就是在不同的页面跳转之间，或者按钮、对话框、列表以及窗口等，通过考虑这些因素去判断一个应用是否易于导航：是否直观？系统的主要模块是否可以通过主页访问或者到达？</p><p>​ 站点是否需要站内地图或者搜索引擎等其他帮助？</p><p>​ web系统导航的另外一个重点就是页面结构、导航、菜单、风格等是否一致，确保用户可以凭借直觉或者简单的判断就可以找到自己想要的内容。</p><p>​ <strong>1.4图形测试</strong></p><p>​ 也可以理解为UI测试，其中包括图片、动画、边框、颜色、字体、背景、按钮等等。</p><p>​ 其中要考虑的几个重点，我做了一个大概的总结：</p><p>​ 1）图片要有明确的用途，代表；图片尺寸尽量小，一般采用JPG或者GIF压缩</p><p>​ 2）页面整体风格是否和系统的用途一致</p><p>​ 3）背景颜色，字体，搭配是否合理</p><p>​ <strong>1.5内容测试</strong></p><p>​ 这个主要用来检测web系统提供信息的准确性、相关性</p><p>​ 比如：商品的价格，文字描述；信息的准确性，是否有拼写错误；信息的相关性，比如很多网站的“相关文章列表，视频列表等”</p><p>​ <strong>1.6整体界面测试</strong></p><p>​ 这个也就是我们常说的用户体验。用户浏览时是否感觉舒适，整体风格等等</p><p>​ 这个我建议一般做一个类似问卷调查的形式，来判定用户的反馈信息，最好有最终用户的参与</p><p><strong>二、兼容性测试</strong></p><p>​ <strong>2.1平台兼容</strong></p><p>​ 现在有很多的操作系统，比如Windows、Unix、Linux、macintosh等；用户使用哪个系统取决于用户，因此，系统兼容测试就很有必要了。</p><p>​ <strong>2.2浏览器兼容</strong></p><p>​ 浏览器是web客户端最核心的组件，不同的浏览器，对Java，JavaScript，css或者HTML的规格都有不同的支持；</p><p>​ 另外，采用的框架和结构风格在不同浏览器中也存在不同的显示甚至不显示，不同的浏览器对安全性的设置也是不同的。</p><p>​ 测试浏览器兼容，有个方法就是创建一个兼容性矩阵，来测试不同厂商不同版本的浏览器兼容。</p><p>​ 比如测试IE浏览器，可以通过一个叫做IEtester的工具来测试兼容，或者可以通过F12控制台来切换浏览器版本来测试兼容以前一些前端元素的显示等</p><p>​ 鉴于国内市场浏览器很多，比如360、搜狗，搜狐、QQ浏览器等，这些本土的浏览器基本都采用的IE浏览器内核的双核配置</p><p><strong>三、安全测试</strong></p><p>​ 我对安全测试了解不多，通过查资料，发现基本的一些安全知识还是互通的，这个就提一下吧</p><p>​ 安全测试的主要区域有以下几点：</p><p>​ 1）现在很多web应用系统都采用先注册后登录的方式，因此，测试用户名和密码的有效无效性，注意大小写敏感，次数限制，是否可以不登录而浏览某些页面等</p><p>​ 2）是否有超时限制</p><p>​ 3）测试用户操作时相关信息是否写入了日志文件、是否可追踪等</p><p>​ 4）如果使用了安全套字，需要测试加密是否正确，加密前后的信息完整性，正确性</p><p>​ 5）没有经过授权，是否可以在服务器端或者前端放置和编辑脚本的问题</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Jul 31 2020 20:37:09 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;&lt;strong&gt;一、功能测试&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;​ &lt;strong&gt;1.1链接测试&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;​ 链接是web应
      
    
    </summary>
    
    
      <category term="Web" scheme="http://yoursite.com/categories/Web/"/>
    
    
      <category term="learn" scheme="http://yoursite.com/tags/learn/"/>
    
  </entry>
  
  <entry>
    <title>http协议（二）请求和响应报文的构成</title>
    <link href="http://yoursite.com/2020/02/18/http2/"/>
    <id>http://yoursite.com/2020/02/18/http2/</id>
    <published>2020-02-18T11:36:41.000Z</published>
    <updated>2020-02-18T11:38:08.659Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Jul 31 2020 20:37:09 GMT+0800 (GMT+08:00) --><p>http协议用于客户端和服务器之间的通信，请求访问资源的一方称为客户端，而提供资源响应的一方称为服务器端。</p><p>下面就是客户端和服务端之间简单的通信过程</p><p><img src="983980-20160630160129390-202840269.png" alt="img"></p><p>PS：请求必须从客户端建立通信，服务端没收到请求之前不会发送响应</p><p>下面先来说说请求的构成：</p><p><strong>1）请求方法URI协议/版本</strong></p><p><strong>2）请求头(Request Header)</strong></p><p><strong>3）请求正文</strong></p><p>下面是一个请求的例子：</p><p>GET/sample.jspHTTP/1.1</p><p>Accept:image/gif.image/jpeg,<em>/</em></p><p>Accept-Language:zh-cn</p><p>Connection:Keep-Alive</p><p>Host:localhost</p><p>User-Agent:Mozila/4.0(compatible;MSIE5.01;Window NT5.0)</p><p>Accept-Encoding:gzip,deflate</p><p>username=jinqiao&amp;password=1234</p><p><strong>1）请求方法URI协议/版本</strong></p><p>以上请求中“GET”代表请求方法，“/sample.jsp”表示URI，“HTTP/1.1代表协议和协议的版本。</p><p>根据HTTP标准，HTTP请求可以使用多种请求方法。具体的方法以及区别后面我们介绍。</p><p><strong>2）请求头</strong></p><p>Accept 可接受的内容类型</p><p>Accept-Language 语言</p><p>Connection连接状态</p><p>Host 请求的域名（这里我设置的是请求本地，当然，关于域名，就是所谓的URL）</p><p>User-Agent 浏览器端浏览器型号和版本</p><p>Accept-Encoding 可接受的压缩类型 gzip,deflate</p><p><strong>3）请求正文</strong></p><p>请求头和请求正文之间是一个空行，它表示请求头已经结束，接下来的是请求正文。请求正文中可以包含客户提交的查询字符串信息：</p><p>username=jinqiao&amp;password=1234</p><p>在以上的例子中，请求的正文只有一行内容。当然，在实际应用中，HTTP请求正文可以包含更多的内容。</p><p><strong>响应的构成</strong></p><p>HTTP响应与HTTP请求相似，HTTP响应也由3个部分构成：</p><p><strong>1）状态行</strong></p><p>*<em>2）响应头<br>*</em></p><p><strong>3）响应正文</strong></p><p>在接收和解释请求消息后，服务器会返回一个HTTP响应消息。</p><p>状态行由协议版本、数字形式的状态代码、及相应的状态描述，各元素之间以空格分隔。</p><p>格式: HTTP-Version Status-Code Reason-Phrase CRLF</p><p>例如: HTTP/1.1 200 OK</p><p><strong>状态代码：</strong></p><p>状态代码由3位数字组成，表示请求是否被理解或被满足。</p><p>状态描述：</p><p>状态描述给出了关于状态代码的简短的文字描述。</p><p>状态代码的第一个数字定义了响应的类别，后面两位没有具体的分类。</p><p>第一个数字有五种可能的取值：</p><p>- 1xx: 指示信息—表示请求已接收，继续处理。</p><p>- 2xx: 成功—表示请求已经被成功接收、理解、接受。</p><p>- 3xx: 重定向—要完成请求必须进行更进一步的操作。</p><p>- 4xx: 客户端错误—请求有语法错误或请求无法实现。</p><p>- 5xx: 服务器端错误—服务器未能实现合法的请求。</p><p>状态代码 状态描述 说明</p><p>200 OK 客户端请求成功</p><p>400 Bad Request 由于客户端请求有语法错误，不能被服务器所理解。</p><p>401 Unauthonzed 请求未经授权。这个状态代码必须和WWW-Authenticate报头域一起使用</p><p>403 Forbidden 服务器收到请求，但是拒绝提供服务。服务器通常会在响应正文中给出不提供服务的原因</p><p>404 Not Found 请求的资源不存在，例如，输入了错误的URL。</p><p>500 Internal Server Error 服务器发生不可预期的错误，导致无法完成客户端的请求。</p><p>503 Service Unavailable 服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常。</p><p><strong>响应头</strong></p><p>响应头可能包括：</p><p>Location：响应报头域用于重定向接受者到一个新的位置。</p><p>Server：响应报头域包含了服务器用来处理请求的软件信息。它和User-Agent请求报头域是相对应的，前者发送服务器端软件的信息，后者发送客户 端软件(浏览器)和操作系统的信息。</p><p>Content-Encoding：实体报头域被使用作媒体类型的修饰符，它的值指示了已经被应用到实体正文的附加内容编码，因而要获得Content- Type报头域中所引用的媒体类型，必须采用相应的解码机制。</p><p>Content-Language：实体报头域描述了资源所用的自然语言。Content-Language允许用户遵照自身的首选语言来识别和区分实体。</p><p>Content-Length：实体报头域用于指明正文的长度，以字节方式存储的十进制数字来表示，也就是一个数字字符占一个字节，用其对应的ASCII码存储传输。</p><p>要注意的是：这个长度仅仅是表示实体正文的长度，没有包括实体报头的长度。</p><p>Content-Type：实体报头域用语指明发送给接收者的实体正文的媒体类型。</p><p>Last-Modified：实体报头域用于指示资源最后的修改日期及时间。</p><p>Expires：实体报头域给出响应过期的日期和时间。</p><p>Expires实体报头域使用的日期和时间必须是RFC 1123中的日期格式，例如：</p><p>Expires: Thu, 15 Sep 2005 16:00:00 GMT</p><p>下面是一个HTTP响应的例子：</p><p>HTTP/1.1 200 OK</p><p>Server:Apache Tomcat/5.0.12</p><p>Date:Mon,6Oct2003 13:23:42 GMT</p><p>Content-Length:112</p><p>从上面的例子大家可以对照着进行比对，或者自己可以尝试在电脑上操作，这里给大家教一个方法：</p><p>使用chrome浏览器自带的开发者工具查看http头的方法</p><p>1.在网页任意地方右击选择审查元素或者按下 shift+ctrl+c或者F12, 打开chrome自带的调试工具;</p><p>2.选择network标签, 刷新网页(在打开调试工具的情况下刷新);</p><p>3.刷新后在左边找到该网页url,点击 后右边选择headers,就可以看到当前网页的http请求和响应</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Jul 31 2020 20:37:09 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;http协议用于客户端和服务器之间的通信，请求访问资源的一方称为客户端，而提供资源响应的一方称为服务器端。&lt;/p&gt;&lt;p&gt;下面就是客户端和服务端之
      
    
    </summary>
    
    
      <category term="Web" scheme="http://yoursite.com/categories/Web/"/>
    
    
      <category term="learn" scheme="http://yoursite.com/tags/learn/"/>
    
  </entry>
  
  <entry>
    <title>http1</title>
    <link href="http://yoursite.com/2020/02/18/http1/"/>
    <id>http://yoursite.com/2020/02/18/http1/</id>
    <published>2020-02-18T10:43:50.000Z</published>
    <updated>2020-02-18T10:47:18.990Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Jul 31 2020 20:37:09 GMT+0800 (GMT+08:00) --><p>当我们在浏览器的地址栏中输入网址，然后点击回车，接着，浏览器就会呈现出我们需要的web界面，那么，这个界面是怎么产生的？</p><p>web的界面是根据我们输入的URL（网址、地址），浏览器从服务器端获取对应的文件资源等信息，然后显示在浏览器上面。</p><p>像这种通过发送请求获取服务器资源的web浏览器等，都可以称之为客户端（client）</p><p>web使用http（超文本传输协议）协议作为规范，来完成从客户端到服务端等一系列的运作流程，而协议指的就是规则的约定，可以说，web是建立在http协议上进行通信的</p><p>关于http的产生和发展，这里就不赘述了，有兴趣的童鞋可以百度。。。。。。</p><p>为了理解http，有必要简单介绍下<strong>tcp/ip协议族</strong></p><p>计算机与网络设备之间互相通信，双方就必须基于同样的方法。比如：如何发现通信目标、由谁发起通信、使用什么语言通信、怎么结束通信都需要事先确定，所有这些都需要一种规则，</p><p>这就是协议。协议中存在多种的内容；从电缆的规格到ip地址的选定方法，寻找异地用户的方法，建立通信的顺序，以及web页面显示需要处理的步骤等等</p><p>像这样<strong>把与互联网相关联的协议集合起来统称为tcp/ip</strong>。</p><p><strong>tcp/ip的分层</strong></p><p>tcp/ip很重要的一个特点就是分层。按照层次分为以下四层：<strong>应用层，传输层，网络层和数据链路层</strong></p><p>分层的好处：如果互联网只由一个协议统筹，那么某一地方出问题，整体都会出现问题，无法使用；分层后，只需替换出现问题的或者需要修改的即可，而且分层后针对具体的设计也变得更为简单</p><p><strong>应用层</strong>：体系的最高层，应用进程间通信交互的规则</p><p>tcp/ip协议族预存了各类通用的应用服务，比如：</p><p>ftp：文件传输协议</p><p>dns：域名系统协议</p><p>http：万维网应用协议</p><p>smtp：电子邮件协议</p><p>以上几种是常用的几种，还有很多其他的协议，感兴趣的可以找找其他专业的书籍看看</p><p><strong>传输层</strong>：提供处于网络连接中的两台计算机间的数据传输，其中包括tcp和udp两种性质不同的协议</p><p>tcp：传输控制协议，传输的单位为报文段，提供面向连接的，可靠的数据传输服务</p><p>udp：传输单位为用户数据报，它是尽最大努力的提供数据传输服务，不保证可靠性</p><p><strong>网络层</strong>：又名网络连接层</p><p>用来处理在网络上流动的数据包（封装）。数据包是网络传输的最小数据单位。该层规定了通过怎样的路径到达对方计算机并把数据包传给对方</p><p><strong>链路层</strong>：又名数据链路层，网络接口层</p><p>处理连接网络的硬件部分。比如控制操作系统、硬件的驱动、网络适配器、光钎等</p><p><strong>数据的封装</strong>：</p><p>用户端发送一个请求，从应用层开始，一直到链路层，每一层都会被打上该层所属的首部信息；反之，接收端在层与层之间传输时，每经过一层会去掉该层的首部信息，这种做法叫做封装</p><p><strong>与http密切相关的协议</strong></p><p>IP协议：位于网络层，作用是把各种数据包传送给对方，而要准确的把数据传送给对方，就需要满足各类条件，其中有2个很重要的条件：ip地址和mac地址</p><p>ip地址相信有点基础的人都知道，就是节点被分配到的地址，mac地址则是指网卡所属的固定地址，ip和mac地址可以进行配对</p><p>ip间的通信依赖于mac地址，在信息传输中，有时候由于中转太多，因此会采用ARP协议，这是个用来解析地址的协议，通过ip地址就可以反查出对应的mac地址</p><p>tcp协议：位于传输层，确保传输的可靠性</p><p>数据传输中为了传输方便，会将大块数据分割成报文段，而tcp协议能确认数据最终是否传送给对方</p><p>为了准确传输，传输中采用了三次握手策略（这种手段可以理解为多次确认，来确保数据传输的可靠性）</p><p>dns协议：负责域名解析，位于应用层，提供域名到ip地址间的解析</p><p>通过域名查找ip地址，或者逆向从ip地址反查域名</p><p><strong>URL和URI</strong></p><p>URL：统一资源定位符：表示资源的地点，具体指向（门牌号）</p><p>URI：统一资源标识符：用字符串标识某些互联网资源（该门牌号的地方具体有什么资源）</p><p>URL是URI的子集</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Jul 31 2020 20:37:09 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;当我们在浏览器的地址栏中输入网址，然后点击回车，接着，浏览器就会呈现出我们需要的web界面，那么，这个界面是怎么产生的？&lt;/p&gt;&lt;p&gt;web的界
      
    
    </summary>
    
    
      <category term="Web" scheme="http://yoursite.com/categories/Web/"/>
    
    
      <category term="learn" scheme="http://yoursite.com/tags/learn/"/>
    
  </entry>
  
  <entry>
    <title>Markdown学习</title>
    <link href="http://yoursite.com/2020/02/18/markdown-0/"/>
    <id>http://yoursite.com/2020/02/18/markdown-0/</id>
    <published>2020-02-18T04:56:57.000Z</published>
    <updated>2020-02-18T10:47:36.598Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Jul 31 2020 20:37:09 GMT+0800 (GMT+08:00) --><p>​ <strong>查看源代码快捷键:Ctrl+/</strong></p><h2 id="1、标题"><a href="#1、标题" class="headerlink" title="1、标题"></a>1、标题</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//标题一共有6个级别，书写方式如下：</span><br><span class="line"><span class="section"># 一级标题</span></span><br><span class="line"><span class="section">## 二级标题</span></span><br><span class="line"><span class="section">### 三级标题</span></span><br><span class="line"><span class="section">#### 四级标题</span></span><br><span class="line"><span class="section">##### 五级标题</span></span><br><span class="line"><span class="section">###### 六级标题</span></span><br></pre></td></tr></table></figure><p>Copy</p><p><strong>具体效果如下：</strong></p><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><hr><h2 id="2、字体"><a href="#2、字体" class="headerlink" title="2、字体"></a>2、字体</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//粗体</span></span><br><span class="line">**你好呀，叶先森**</span><br><span class="line"></span><br><span class="line"><span class="comment">//斜体</span></span><br><span class="line">*我喜欢你*</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除线</span></span><br><span class="line">~~此内容为废弃内容~~</span><br></pre></td></tr></table></figure><p>Copy</p><p><strong>具体效果如下：</strong></p><p><strong>你好呀，叶先森</strong> <em>我喜欢你</em></p><p><del>此内容为废弃内容</del></p><hr><h2 id="3、引用"><a href="#3、引用" class="headerlink" title="3、引用"></a>3、引用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引用书写语法如下：</span></span><br><span class="line"></span><br><span class="line">&gt;此教程来自小小叶儿出品，版权所有，违版必究</span><br><span class="line">&gt;&gt;此教程来自小小叶儿出品，版权所有，违版必究</span><br><span class="line">&gt;&gt;&gt;此教程来自小小叶儿出品，版权所有，违版必究</span><br></pre></td></tr></table></figure><p>Copy</p><blockquote><p>此教程来自小小叶儿出品，版权所有，违版必究</p><blockquote><p>此教程来自小小叶儿出品，版权所有，违版必究</p><blockquote><p>此教程来自小小叶儿出品，版权所有，违版必究</p></blockquote></blockquote></blockquote><h2 id="4、分割线"><a href="#4、分割线" class="headerlink" title="4、分割线"></a>4、分割线</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分隔线（长度：根据内容而定）</span></span><br><span class="line">---</span><br><span class="line"><span class="comment">//分割线（占全屏）</span></span><br><span class="line">***</span><br></pre></td></tr></table></figure><p>Copy</p><hr><hr><h2 id="5、图片"><a href="#5、图片" class="headerlink" title="5、图片"></a>5、图片</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//图片插入</span></span><br><span class="line">![图片名称](图片地址-可以本地：也可以网络)</span><br></pre></td></tr></table></figure><p>Copy</p><h3 id="5-1本地图片："><a href="#5-1本地图片：" class="headerlink" title="5.1本地图片："></a>5.1本地图片：</h3><p><img src="http://47.104.231.144/blog/images/me4.png" alt="由于本地图片是在网页上是无法直接显示的，看语法就行"></p><h3 id="5-2网络图片："><a href="#5-2网络图片：" class="headerlink" title="5.2网络图片："></a>5.2网络图片：</h3><p>!(<a href="http://47.104.231.144:9999/blog/images/me4.png" target="_blank" rel="noopener">http://47.104.231.144:9999/blog/images/me4.png</a>)</p><hr><h2 id="6、超链接"><a href="#6、超链接" class="headerlink" title="6、超链接"></a>6、超链接</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//超链接</span></span><br><span class="line">[点击跳转到我的GitHub](https:<span class="comment">//github.com/lipliu)</span></span><br></pre></td></tr></table></figure><p>Copy</p><p><a href="www.baidu.com">dd</a></p><p><strong>效果如下：</strong></p><p><a href="https://github.com/yerenping" target="_blank" rel="noopener">点击跳转到我的GitHub</a></p><hr><h2 id="7、列表"><a href="#7、列表" class="headerlink" title="7、列表"></a>7、列表</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有序列表：序号+点+空格，生成列表 </span></span><br><span class="line"><span class="number">1</span>. 首页</span><br><span class="line"><span class="number">2</span>. 分类</span><br><span class="line"><span class="number">3</span>. 标题</span><br><span class="line"><span class="comment">//无需列表：- + 空格</span></span><br><span class="line">-</span><br></pre></td></tr></table></figure><p>Copy</p><p><strong>有序：</strong></p><ol><li>首页</li><li>分类</li><li>标题</li></ol><p><strong>无序：</strong></p><p>-</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Jul 31 2020 20:37:09 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;​ &lt;strong&gt;查看源代码快捷键:Ctrl+/&lt;/strong&gt;&lt;/p&gt;&lt;h2 id=&quot;1、标题&quot;&gt;&lt;a href=&quot;#1、标题&quot; clas
      
    
    </summary>
    
    
      <category term="hobby" scheme="http://yoursite.com/categories/hobby/"/>
    
    
      <category term="learn" scheme="http://yoursite.com/tags/learn/"/>
    
  </entry>
  
  <entry>
    <title>摄影基础知识</title>
    <link href="http://yoursite.com/2019/12/21/page/"/>
    <id>http://yoursite.com/2019/12/21/page/</id>
    <published>2019-12-21T13:02:01.000Z</published>
    <updated>2019-12-21T13:11:27.770Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Jul 31 2020 20:37:09 GMT+0800 (GMT+08:00) --><p><strong>1.不同焦段对人的影响</strong></p><p>1.24mm,35mm,55mm,90mm,135mm(SONY F1.8GM)</p><p>2.24,35偏广角镜头，四角拉伸都感觉，偏大教堂，景点</p><p>3.85mm最适合拍人像</p><p>4.长焦135mm,人物和想要出现的背景</p><p>5.平常55mm，初学者</p><p><strong>2.什么是快门，光圈和ISO？</strong></p><p>快门：相机右下角数字 1/25 1/60 快门的速度，打开到闭合，定格时间越短，越慢对曝光也有影响，曝光度越高，夜景用三脚架</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Jul 31 2020 20:37:09 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;&lt;strong&gt;1.不同焦段对人的影响&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;1.24mm,35mm,55mm,90mm,135mm(SONY F1.8
      
    
    </summary>
    
    
      <category term="life" scheme="http://yoursite.com/categories/life/"/>
    
    
      <category term="hobby" scheme="http://yoursite.com/tags/hobby/"/>
    
  </entry>
  
</feed>
